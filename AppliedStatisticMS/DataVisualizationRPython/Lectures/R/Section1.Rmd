---
title: "Visualización de Datos con R Sección 1"
author:
  - name: "Lihki Rubio"
    url: https://github.com/lihkir/Uninorte
    affiliation: Universidad del Norte
output:
  rmdformats::readthedown:
  self_contained: true
  thumbnails: true
  lightbox: true
  gallery: false
  highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción a R

## Instalación e Interfaz

Lo primero que debe hacer para empezar a utilizar **R** es instalarlo en su ordenador. **R** funciona en casi todas las plataformas disponibles, incluidos los sistemas **Windows, Mac OS X** y **Linux**. Links de descarga para [R](https://cloud.r-project.org/) y [RStudio](https://www.rstudio.com/products/rstudio/download/). 

**RStudio** es un entorno de desarrollo integrado (**IDE**) disponible para **R**, el cual tiene un buen editor con resaltado de sintaxis, un visor de objetos de **R** y un gran número de características agradables que están integradas.

# Gestión de Data Frames con el paquete paquete dplyr

## Data Frames

El *data frame* es una estructura de datos clave en estadística y en **R**. La estructura básica de un *data frame* es que hay una observación por fila y cada columna representa una variable, medida, rasgo o característica de esa observación. **R** tiene una implementación interna de los *data frame* que es probablemente la que se utiliza con más frecuencia.

## El paquete dplyr

El paquete **dplyr** fue desarrollado por Hadley Wickham de RStudio y es una versión optimizada y destilada de su paquete **plyr**. Una importante contribución del paquete **dplyr** es que proporciona una "gramática" (en particular, verbos) para la manipulación de datos y para operar con *data frames*. Con esta gramática, se puede comunicar de forma comprensible lo que se está haciendo a un *data frame*. Esto es útil porque proporciona una abstracción para la manipulación de datos que antes no existía. Otra contribución útil es que las funciones de **dplyr** son muy rápidas, ya que muchas operaciones clave están codificadas en **C++**.

## Gramática dplyr

Algunos de los "verbos" clave proporcionados por el paquete **dplyr** son

- *select*: devuelve un subconjunto de las columnas de un *dataframe*, utilizando una notación flexible
- *filter*: extraer un subconjunto de filas de un *dataframe* basándose en condiciones lógicas
- *arrange*: reordenar las filas de un *dataframe*
- *rename*: renombrar las variables de un *dataframe*
- *mutate*: añadir nuevas variables/columnas o transformar variables existentes
- *summarise/summarize*: generar estadísticas de resumen de diferentes variables en el
*dataframe*, posiblemente dentro de los estratos
- *%>%*: el operador "pipe" se utiliza para conectar varias acciones verbales en una
*pipeline*

## Propiedades comunes de la función dplyr

Todas las funciones que trataremos en este capítulo tendrán algunas características comunes. En particular,

1. El primer argumento es un *dataframe*.
2. Los argumentos siguientes describen qué hacer con el *dataframe* especificado en el primer argumento, y puede referirse a las columnas del *dataframe* directamente sin usar el operador $ (sólo use los nombres de las columnas).
3. El resultado de retorno de una función es un nuevo *dataframe*
4. Los *dataframes* deben estar correctamente formateados y anotados para que todo esto sea útil. En resumen, debe haber una observación por fila y cada columna debe representar un rasgo o característica de esa observación.

## Instalación del paquete dplyr

El paquete dplyr se puede instalar desde *CRAN* o desde *GitHub* utilizando el paquete **devtools** y la función **install_github()**. El repositorio de *GitHub* suele contener las últimas actualizaciones del paquete y la versión de desarrollo. 

- Para instalarlo desde *CRAN*, basta con ejecutar

```{r eval=FALSE}
install.packages("dplyr")
```

- Para instalar desde *GitHub* puedes ejecutar

```{r eval=FALSE}
install_github("hadley/dplyr")
```

- Después de instalar el paquete es importante que lo cargues en tu sesión de **R** con la función **library()**

```{r}
library(dplyr)
```

- Si la instalación de **dplyr** no fué realizada correctamente, un mensaje de instalación requerida aparecerá resaltado en amarillo en la parte superior de **RStudio**. Haga click en **Install** y espero un momento mientras se lleva a cabo la instalación. Puede usar también esta estrategia de instalación en lo que sigue

<br/>
<center>
![](Figures/section1_fig1.png){width=90%}
<center>
<br/><br/>

- **NOTA**: Si alguna vez se encuentra con un problema en el que **R** se confunde sobre qué función que quiere llamar, puede especificar el nombre completo de una función utilizando el operador **::**. Por ejemplo, la función de **filter** del paquete **dplyr** tiene el nombre completo **dplyr::filter**. Llamar a las funciones con su nombre completo resolverá cualquier confusión sobre la función a la que se quiere llamar.

## select()

Para los ejemplos de esta sección utilizaremos un conjunto de datos que contiene información sobre la contaminación del aire y la temperatura de la ciudad de Chicago. Todos los datos usados en este curso los podrás descargar en: [RDataSets](https://github.com/lihkir/Uninorte/blob/main/AppliedStatisticMS/DataVisualizationRPython/Lectures/R/RDataSets.zip)

- Después de descomprimir el archivo, puede cargar los datos en R utilizando la función **readRDS()**.

```{r}
chicago <- readRDS("RDataSets/chicago.rds")
```

- Puede ver algunas características básicas del conjunto de datos con las funciones **dim()** y **str()**.

```{r}
dim(chicago)
```

```{r}
str(chicago)
```

- La función **select() **puede utilizarse para seleccionar las columnas de un *dataframe* en las que desee centrarse. A menudo se tiene un *datafreame* grande que contiene "todos" los datos, pero un análisis determinado puede utilizar sólo un subconjunto de variables u observaciones. La función **select()** le permite obtener las pocas columnas que pueda necesitar. 

- Supongamos que queremos tomar sólo las 3 primeras columnas. Hay varias formas de hacerlo. Podríamos, por ejemplo, utilizar índices numéricos. Pero también podemos utilizar los nombres directamente.

```{r}
names(chicago)[1:3]
subset <- select(chicago, names(chicago)[1:3])
head(subset)
subset <- select(chicago, city:dptp)
head(subset)
```
- Tenga en cuenta que el signo **:** normalmente no se puede utilizar con nombres o cadenas, pero dentro de la función **select()** puede utilizarlo para especificar un rango de nombres de variables. También puede omitir variables con la función **select()** utilizando el signo negativo

```{r}
subset <- select(chicago, -(city:dptp))
head(subset)
```
- El código equivalente en **R** base sería el siguiente, el cual es menos intuitivo

```{r}
i <- match("city", names(chicago))
j <- match("dptp", names(chicago))
head(chicago[, -(i:j)])
```
- La función **select()** también permite una sintaxis especial que permite especificar nombres de variables basados en patrones. Así, por ejemplo, si quisiéramos conservar todas las variables que terminan con un "2", podríamos hacer

```{r}
subset <- select(chicago, ends_with("2"))
str(subset)
```
- O si quisiéramos mantener todas las variables que empiezan por "d", podríamos hacer

```{r}
subset <- select(chicago, starts_with("d"))
str(subset)
```

- También puede utilizar expresiones regulares más generales si es necesario. Consulte la página de ayuda escribiendo en consola *(??select)* para más detalles.

## filter()

- La función **filter()** se utiliza para extraer subconjuntos de filas de un *dataframe*. Esta función es similar a la función **subset()** existente en **R**, pero es bastante más rápida. Supongamos que queremos extraer las filas del **dataframe** PM2.5 que sean superiores a 30 (que es un nivel razonablemente alto), podríamos hacer

```{r}
chic.f <- filter(chicago, pm25tmean2 > 30)
str(chic.f)
```

- Puede ver que ahora sólo hay 194 filas en el dataframe y la distribución de los valores de pm25tmean2 es

```{r}
summary(chic.f$pm25tmean2)
```

- Podemos colocar una secuencia lógica arbitrariamente compleja dentro de **filter()**, por lo que podríamos, por ejemplo, extraer las filas en las que PM2.5 es mayor que 30 y la temperatura es mayor que 80 grados Fahrenheit

```{r}
chic.f <- filter(chicago, pm25tmean2 > 30 & tmpd > 80)
select(chic.f, date, tmpd, pm25tmean2)
```

## arrange()

- La función **arrange()** se utiliza para reordenar las filas de un *dataframe* según una de las variables/columnas. Reordenar las filas de un *dataframe* (conservando el orden correspondiente de otras columnas) suele ser una tarea ardua en **R**. La función **arrange()** simplifica la tarea

- Aquí podemos ordenar las filas del dataframe por fecha, de modo que la primera fila sea la observación más antigua y la última la más reciente

```{r}
chicago <- arrange(chicago, date)
```

- Ahora podemos comprobar las primeras filas

```{r}
head(select(chicago, date, pm25tmean2), 3)
```
- Las últimas filas

```{r}
tail(select(chicago, date, pm25tmean2), 3)
```

- Las columnas también se pueden ordenar de forma descendente utilizando el operador especial **desc()**

```{r}
chicago <- arrange(chicago, desc(date))
head(chicago)
```
- Si se observan las tres primeras y las tres últimas filas, las fechas aparecen en orden descendente

```{r}
head(select(chicago, date, pm25tmean2), 3)
tail(select(chicago, date, pm25tmean2), 3)
```

## rename()

- Renombrar una variable en un *dataframe* en **R** es sorprendentemente difícil de hacer. La función **rename()** está diseñada para facilitar este proceso. Aquí puedes ver los nombres de las cinco primeras variables del data frame de chicago.

```{r}
head(chicago[, 1:5], 3)
```

- La columna *dptp* se supone que representa la temperatura del punto de rocío y la columna *pm25tmean2* proporciona los datos *PM2.5*. Sin embargo, estos nombres son incómodos y probablemente deban ser renombrados a algo más sencillos

```{r}
chicago <- rename(chicago, dewpoint = dptp, pm25 = pm25tmean2)
head(chicago[, 1:5], 3)
```

- La sintaxis dentro de la función **rename()** es tener el nuevo nombre en el lado izquierdo del signo **=** y el nombre antiguo en el lado derecho.

## mutate()

- La función **mutate()** existe para calcular las transformaciones de las variables de un *dataframe*. A menudo, se desea crear nuevas variables derivadas de variables existentes y **mutate()** proporciona una interfaz limpia para hacerlo. Por ejemplo, con los datos de contaminación atmosférica, a menudo queremos eliminar la tendencia de los datos restando la media de los mismos De este modo, podemos ver si el nivel de contaminación atmosférica de un día determinado es es superior o inferior a la media (en lugar de observar su nivel absoluto). Aquí creamos una variable *pm25detrend* que resta la media de la variable *pm25*.

```{r}
 chicago <- mutate(chicago, pm25detrend = pm25 - mean(pm25, na.rm = TRUE))
head(chicago)
```

- También existe la función relacionada **transmute()**, que hace lo mismo que **mutate()** pero luego elimina todas las variables no transformadas. En este caso, se desdiferencian las variables *PM10* y ozono *(O3)*

```{r}
head(transmute(chicago, 
               pm10detrend = pm10tmean2 - mean(pm10tmean2, na.rm = TRUE),
               o3detrend = o3tmean2 - mean(o3tmean2, na.rm = TRUE)))
```

- Observe que sólo hay dos columnas en el *dataframe* transmutado.

## group_by()

- La función **group_by()** se utiliza para generar estadísticas de resumen del *dataframe* dentro de los estatus definidos por una variable. Por ejemplo, en este conjunto de datos de contaminación atmosférica, podría querer saber cuál es el nivel medio anual de *PM2,5*. Entonces el estatus es el año, y eso es algo que podemos derivar de la variable fecha. Junto con la función **group_by()** se suele utilizar la función **summarize()** (o **summarise()** para algunas partes del mundo). La operación general aquí es una combinación de dividir un *dataframe* en piezas separadas definidos por una variable o grupo de variables (**group_by()**), y luego aplicar una función de resumen en esos subconjuntos (**summarize()**). En primer lugar, podemos crear una variable de año utilizando **as.POSIXlt()**.

```{r}
chicago <- mutate(chicago, year = as.POSIXlt(date)$year + 1900)
head(chicago)
```
- Ahora podemos crear un *dataframe* separado que divida el *dataframe* original por año

```{r}
years <- group_by(chicago, year)
```

- Por último, calculamos las estadísticas de resumen para cada año del *dataframe* con la función **summarize()**.

```{r}
summarize(years, pm25 = mean(pm25, na.rm = TRUE),
          o3 = max(o3tmean2, na.rm = TRUE),
          no2 = median(no2tmean2, na.rm = TRUE))
```

- **summarize()** devuelve un *dataframe* con el año como primera columna, y luego los promedios anuales de *pm25*, *o3* y *no2*. 

- En un ejemplo algo más complicado, podríamos querer saber cuáles son los niveles medios de de ozono (*o3*) y dióxido de nitrógeno (*no2*) dentro de los quantiles de *pm25*. Una forma más sencilla de de hacerlo sería a través de un modelo de regresión, pero en realidad podemos hacerlo rápidamente con **group_by()** y **summarize()**. Primero, podemos crear una variable categórica de *pm25* dividida en quantiles.

```{r}
qq <- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)
chicago <- mutate(chicago, pm25.quint = cut(pm25, qq))
```

- Ahora podemos agrupar el *dataframe* por la variable *pm25.quint*.

```{r}
quint <- group_by(chicago, pm25.quint)
```

- Por último, podemos calcular la media de *o3* y *no2* dentro de los quantiles de *pm25*

```{r}
summarize(quint, o3 = mean(o3tmean2, na.rm = TRUE), no2 = mean(no2tmean2, na.rm = TRUE))

```

- Según la tabla, parece que no hay una relación fuerte entre *pm25* y *o3*, pero parece haber una correlación positiva entre *pm25* y *no2*. Una modelización estadística más sofisticada puede ayudar a dar respuestas precisas a estas preguntas, pero una simple aplicación de las funciones *dplyr* puede llevarle a la mayoría de los caminos.

## %>%

- El operador pipeline **%>%** es muy útil para encadenar múltiples funciones *dplyr* en una secuencia de operaciones. Fíjate que cada vez que queríamos aplicar más de una función, la secuencia quedaba enterrada en una secuencia de llamadas a funciones anidadas que era difícil de leer, por ejemplo

```{r eval=FALSE}
third(second(first(x)))
```

- Este anidamiento no es una forma natural de pensar en una secuencia de operaciones. El operador **%>%** permite encadenar las operaciones de izquierda a derecha, es decir

```{r eval=FALSE}
first(x) %>% second %>% third
```

- Tomemos el ejemplo que acabamos de hacer en la última sección, en el que hemos calculado la media de *o3* y *no2* dentro de los quantiles de *pm25*. Allí tuvimos que

1. create a new variable *pm25.quint*
2. dividir el *dataframe* por esa nueva variable
3. calcular la media de *o3* y *no2* en los subgrupos definidos por *pm25.quint*

- Eso se puede hacer con la siguiente secuencia en una sola expresión de **R**

```{r}
mutate(chicago, pm25.quint = cut(pm25, qq)) %>%
  group_by(pm25.quint) %>%
  summarize(o3 = mean(o3tmean2, na.rm = TRUE),
            no2 = mean(no2tmean2, na.rm = TRUE))
```

- De esta manera no tenemos que crear un conjunto de variables temporales en el camino o crear una secuencia masiva anidada de llamadas a funciones. Observe en el código anterior que paso el *dataframe* chicago a la primera llamada a **mutate()**, pero después no tengo que pasar el primer argumento a **group_by()** o a **summarize()**. Una vez que se recorre la *pipeline* con **%>%**, el primer argumento se toma como la salida del elemento anterior en la *pipeline*

- Otro ejemplo podría ser el cálculo del nivel medio de contaminantes por mes. Esto podría Esto podría ser útil para ver si hay alguna tendencia estacional en los datos.

```{r}
mutate(chicago, month = as.POSIXlt(date)$mon + 1) %>%
  group_by(month) %>%
  summarize(pm25 = mean(pm25, na.rm = TRUE),
            o3 = max(o3tmean2, na.rm = TRUE),
            no2 = median(no2tmean2, na.rm = TRUE))
```

- Aquí podemos ver que el *o3* tiende a ser bajo en los meses de invierno y alto en el verano mientras que *no2* es más alto en invierno y más bajo en verano.

# Graficar un conjunto de datos

- El paquete **ggplot2** puede utilizarse para crear varios tipos de gráficos y diagramas a partir de un *dataframe*. La función **ggplot()** se utiliza para definir gráficos, y se le pueden pasar una serie de parámetros y unirse a otras funciones para producir finalmente un gráfico de salida. El primer parámetro que se pasa a **ggplot()** es el *dataframe* que se quiere representar. Normalmente será un objeto *dataframe*, pero también puede ser un subconjunto de un *dataframe* definido con la función **subset()**.

```{r}
library(readr)
dfCrime = read_csv("RDataSets/Crime_Data.csv", col_names = TRUE)
```

- Puede obtener un recuento del número de registros con la función. La función **View()** se puede utilizar para ver los datos en un formato tabular.

```{r}
nrow(dfCrime)
View(dfCrime)
```

- En este caso limitaremos las columnas a lo siguiente: *Reported Date, Crime Subcategory, Primary Offense Description, Precinct, Sector, Beat y Neighborhood*

```{r}
dfCrime = select(dfCrime,
                 "Reported Date",
                 "Crime Subcategory",
                 "Primary Offense Description",
                 "Precinct",
                 "Sector",
                 "Beat",
                 "Neighborhood")
```

- También es posible que quiera cambiar el nombre de las columnas para que sean más fáciles de leer o simplificar los nombres. La función **select()** se puede utilizar para hacer esto también.

```{r}
dfCrime = select(dfCrime, 
                 "CrimeDate" = "Reported Date", 
                 "Category" = "Crime Subcategory", 
                 "Description" = "Primary Offense Description", 
                 "Precinct",
                 "Sector", 
                 "Beat", 
                 "Neighborhood")
```

- El filtrado del conjunto de datos le permite centrarse en un subconjunto de filas en lugar de en todo el conjunto de datos. El paquete **dplyr** incluye una función **filter()** que soporta esta capacidad

```{r}
dfCrime2 = filter(dfCrime, Neighborhood == "QUEEN ANNE")
nrow(dfCrime2)
```

- También puede incluir varias expresiones en una función **filter()**, como sigue. Examinaremos expresiones de filtro más complejas en una sección posterior

```{r}
dfCrime3 = filter(dfCrime, 
                  Neighborhood == "QUEEN ANNE", 
                  Category == "BURGLARY-RESIDENTIAL")
```

- En la ventana de la consola de RStudio añada el código que ve a continuación para agrupar los delitos por ronda policial

```{r}
dfCrime2 = group_by(dfCrime2, Beat)
```

- La función **n()** se utiliza para obtener un recuento del número de registros de cada grupo. Añada a el código que se ve a continuación

```{r}
dfCrime2 = summarise(dfCrime2, n = n())
head(dfCrime2)
```

## Ejemplo de grafico con ggplot()

- En la consola de **RStudio** añada el código que ve a continuación. La función **ggplot()** en este caso se le pasa el *dataframe* *dfCrime*. La función **geom_col()** se utiliza para definir la geometría del gráfico (diagrama de barras) y se le pasa un parámetro de asignación que se define llamando a la función **aes()** y pasando las columnas para el eje **x** (Beat), y el eje **y** (**n = count**)

```{r}
library("ggplot2")
ggplot(data=dfCrime2) + geom_col(mapping = aes(x = Beat, y = n), fill = "red")
```

## Gráficos de robos por mes y año

- En este ejercicio crearemos un par de gráficos de barras que muestren el número de robos por año y por mes para el barrio de Queen Anne. Además de los paquetes **dplyr** y **ggplot2** que que usamos anteriormente, también usaremos el paquete **lubridate** para manipular la información de las fechas.

- En el panel de paquetes de **RStudio**, cargue el paquete **lubridate**. El paquete **lubridate** forma parte de **tidyverse** y se utiliza para trabajar con fechas y horas. Además, asegúrese de que los paquetes **readr, dplyr y ggplot2** están cargados

```{r}
library(readr)
dfCrime = read_csv("RDataSets/Crime_Data.csv", col_names = TRUE)
```

- Especifique las columnas y los nombres de las columnas

```{r}
dfCrime = select(dfCrime, 
                 "CrimeDate" = "Reported Date",
                 "Category" = "Crime Subcategory",
                 "Description" = "Primary Offense Description", 
                 "Precinct",
                 "Sector", 
                 "Beat", 
                 "Neighborhood")
```

- Filtrar los registros para que sólo se conserven los robos residenciales en el barrio de Queen Anne

```{r}
dfCrime2 = filter(dfCrime, 
                  Neighborhood == "QUEEN ANNE", 
                  Category == "BURGLARY-RESIDENTIAL")
```

- El paquete **dplyr** incluye la capacidad de crear dinámicamente nuevas columnas en un *dataframe* mediante la manipulación de los datos de las columnas existentes en el *dataframe*. La función **mutate()** se utiliza para crear las nuevas columnas. Aquí la función **mutate()** se utilizará para extraer el año de la columna *CrimeDate*. Agregue el siguiente código para ver esto en acción. El segundo parámetro crea una nueva columna columna llamada *YEAR* y la rellena utilizando la función **year()** del paquete del paquete **lubridate**. Dentro de la función **year()** la columna *CrimeDate*, que es una columna de caracteres columna de caracteres, se convierte en una fecha y el formato de la fecha

```{r}
library(lubridate)
dfCrime3 = mutate(dfCrime2, YEAR = year(as.Date(dfCrime2$CrimeDate,format="%m/%d/%Y")))
```

- Vea el resultado. Observe la columna *YEAR* al final del *dataframe*. La función **mutate()** siempre añade nuevas columnas al final del *dataframe*

```{r}
head(dfCrime3)
```

- Ahora agruparemos los datos por año y resumiremos obteniendo un recuento del número de delitos por año

```{r}
dfCrime4 = group_by(dfCrime3, YEAR)
dfCrime4 = summarise(dfCrime4, n = n())
head(dfCrime4)
```

- Cree un gráfico de barras llamando a las funciones **ggplot()** y **geom_col()** como se ve abajo. Defina **YEAR** como columna para el eje **x** y el número de delitos para el eje el eje **y**. Esto debería producir el gráfico que se ve a continuación en el panel Plots

```{r}
ggplot(data=dfCrime4) + geom_col(mapping = aes(x=YEAR, y=n), fill="red")
```

